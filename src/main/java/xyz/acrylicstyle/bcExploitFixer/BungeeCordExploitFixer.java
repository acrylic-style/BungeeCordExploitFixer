package xyz.acrylicstyle.bcExploitFixer;

import util.ArgumentParser;
import util.ICollectionList;
import util.reflector.Reflector;
import util.yaml.YamlConfiguration;
import util.yaml.YamlObject;
import xyz.acrylicstyle.bcExploitFixer.reflector.VirtualMachine;
import xyz.acrylicstyle.bcExploitFixer.transformers.NullPacketTransformer;
import xyz.acrylicstyle.bcExploitFixer.transformers.BlockOversizedPacketTransformer;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.PrintWriter;
import java.lang.instrument.ClassFileTransformer;
import java.lang.instrument.Instrumentation;
import java.lang.management.ManagementFactory;
import java.lang.reflect.InvocationTargetException;
import java.net.URI;
import java.net.URISyntaxException;
import java.net.URL;
import java.net.URLClassLoader;
import java.nio.file.FileSystem;
import java.nio.file.FileSystems;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.StandardCopyOption;
import java.util.HashMap;
import java.util.Map;
import java.util.NoSuchElementException;
import java.util.jar.JarFile;
import java.util.jar.Manifest;

public class BungeeCordExploitFixer {
    public static Instrumentation inst;
    public static boolean init = false;
    public static boolean debug = false;
    public static boolean verbose = false;
    public static boolean closeConnectionWhenNullPacket = true;
    public static boolean blockOversizedPacket = true;
    public static boolean disableWaterfallCompatibility = false;

    public static void agentmain(String arg, Instrumentation instrumentation) {
        inst = instrumentation;
        init(arg);
    }

    public static void premain(String arg, Instrumentation instrumentation) {
        inst = instrumentation;
        init(arg);
    }

    public static void main(String[] args) throws InterruptedException {
        // https://bugs.java.com/bugdatabase/view_bug.do?bug_id=8180425
        if (getVersion() >= 9 && !Boolean.getBoolean("jdk.attach.allowAttachSelf")) {
            error("BungeeCordExploitFixer does not work without jdk.attach.allowAttachSelf=true.");
            error("Please set jdk.attach.allowAttachSelf=true.");
            error("Example: java -Xmx2G -D\"jdk.attach.allowAttachSelf=true\" -jar BungeeCordExploitFixer.jar BungeeCord.jar");
            error("Or run as javaagent: java -Xmx2G -javaagent:BungeeCordExploitFixer.jar BungeeCord.jar");
            System.exit(1);
        }
        if (args.length == 0) {
            error("Usage: java <jvm arguments> -jar BungeeCordExploitFixer.jar <jar file of BungeeCord> [arguments]");
            System.exit(1);
        }
        File jarFile = new File(args[0]);
        if (!jarFile.exists() || jarFile.isDirectory()) {
            error("BungeeCord jar file does not exist or is directory");
            System.exit(1);
        }
        init(String.join(" ", args));
        try {
            JarFile jar = new JarFile(jarFile);
            Manifest manifest = jar.getManifest();
            if (manifest == null) throw new UnsupportedOperationException("Manifest file does not exist");
            String mainClass = manifest.getMainAttributes().getValue("Main-Class");
            if (mainClass == null) throw new UnsupportedOperationException("Main-Class attribute does not exist");
            URLClassLoader cl = URLClassLoader.newInstance(new URL[]{ jarFile.toURI().toURL() });
            inst.appendToSystemClassLoaderSearch(jar);
            Thread.currentThread().setContextClassLoader(cl);
            cl.loadClass(mainClass).getMethod("main", String[].class).invoke(null, (Object) ICollectionList.asList(args).limit(1).toArray(new String[0]));
        } catch (Throwable throwable) {
            error("Failed to invoke main method");
            throwable.printStackTrace();
            if (throwable instanceof InvocationTargetException) {
                log("Caused by:");
                ((InvocationTargetException) throwable).getTargetException().printStackTrace();
            }
            Thread.sleep(100); // give enough time to dump error
            System.exit(1);
        }
    }

    public static void init(String arg) {
        if (init) return;
        init = true;
        if (arg == null) arg = "";
        File configFile = new File("./bungeeCordExploitFixer.yml");
        YamlConfiguration yamlConfiguration;
        try {
            if (!configFile.exists()) {
                //noinspection ResultOfMethodCallIgnored
                configFile.createNewFile();
            }
            if (!configFile.isFile()) {
                error(configFile.getAbsolutePath() + " is not a file.");
                System.exit(1);
            }
            yamlConfiguration = new YamlConfiguration(configFile);
        } catch (IOException ex) {
            throw new RuntimeException(ex);
        }
        YamlObject yaml = yamlConfiguration.asObject();
        debug = yaml.getBoolean("debug", false);
        verbose = yaml.getBoolean("verbose", false);
        closeConnectionWhenNullPacket = yaml.getBoolean("close-connection-when-null-packet", true);
        blockOversizedPacket = yaml.getBoolean("block-oversized-packet", true);
        disableWaterfallCompatibility = yaml.getBoolean("disable-waterfall-compatibility", false);
        yaml.set("debug", debug);
        yaml.set("verbose", verbose);
        yaml.set("close-connection-when-null-packet", closeConnectionWhenNullPacket);
        yaml.set("block-oversized-packet", blockOversizedPacket);
        yaml.set("disable-waterfall-compatibility", disableWaterfallCompatibility);
        try {
            yaml.save(configFile);
        } catch (IOException ex) {
            error("Failed to save configuration to " + configFile.getAbsolutePath() + ": " + ex.getClass().getSimpleName() + ": " + ex.getMessage());
        }
        // arguments can only be "disableWaterfallCompatibility", "debug" or "verbose", other arguments will be ignored
        ArgumentParser parser = new ArgumentParser(arg);
        if (parser.contains("help")) {
            log("BungeeCordExploitFixer by acrylic-style");
            log("");
            log("Arguments:");
            log("  --debug");
            log("    -> Enable debug logging");
            log("  -v");
            log("  --verbose");
            log("    -> Enable verbose logging");
            log("  --disableWaterfallCompatibility");
            log("  --disable-waterfall-compatibility");
            log("  --no-wf");
            log("    -> Disable waterfall compatibility, some waterfall specific features will be turned off");
            System.exit(0);
        }
        if (parser.contains("debug")) debug = true;
        if (parser.contains("verbose") || parser.contains("v")) verbose = true;
        if (parser.contains("disableWaterfallCompatibility") || parser.contains("disable-waterfall-compatibility") || parser.contains("no-wf")) disableWaterfallCompatibility = true;
        try {
            getInstrumentation();
        } catch (Throwable throwable) {
            throw new RuntimeException(throwable);
        }
        log("debug: " + debug);
        log("verbose: " + verbose);
        log("closeConnectionWhenNullPacket (NullPacketTransformer): " + closeConnectionWhenNullPacket);
        log("blockOversizedPacket (BlockOversizedPacketTransformer): " + blockOversizedPacket);
        log("disableWaterfallCompatibility: " + disableWaterfallCompatibility);
        // Add transformers
        addTransformer(closeConnectionWhenNullPacket, new NullPacketTransformer());
        addTransformer(blockOversizedPacket, new BlockOversizedPacketTransformer());
    }

    public static void addTransformer(boolean condition, ClassFileTransformer transformer) {
        if (inst != null && condition) inst.addTransformer(transformer);
    }

    @SuppressWarnings("UnusedReturnValue")
    private static Instrumentation getInstrumentation() throws Throwable {
        if (inst != null) return inst;
        File tools_jar = new File(System.getProperty("java.home") + "/../lib/tools.jar");
        if (!tools_jar.exists()) {
            tools_jar = new File(System.getProperty("java.home") + "/lib/tools.jar");
            if (!tools_jar.exists()) {
                log("Could not find tools.jar, might not be able to startup correctly.");
            }
        }
        Reflector.classLoader = !tools_jar.exists() ? BungeeCordExploitFixer.class.getClassLoader() : URLClassLoader.newInstance(new URL[] { tools_jar.toURI().toURL() }, BungeeCordExploitFixer.class.getClassLoader());
        VirtualMachine vm = VirtualMachine.attach(ManagementFactory.getRuntimeMXBean().getName().replaceAll("(.*)@.*", "$1"));
        File file = new File(BungeeCordExploitFixer.class.getProtectionDomain().getCodeSource().getLocation().getFile());
        if (file.isDirectory()) {
            File dir = file;
            file = File.createTempFile("bcExploitFixer", ".jar");
            log("Creating jar file on " + file.toURI());
            file.deleteOnExit();
            //noinspection ResultOfMethodCallIgnored
            Runtime.getRuntime().addShutdownHook(new Thread(file::delete));
            createZipFile(file, dir);
        }
        log("Loading agent: " + file.getAbsolutePath());
        vm.loadAgent(file.getAbsolutePath());
        vm.detach();
        if (inst == null) throw new IllegalStateException("Agent was not loaded");
        return inst;
    }

    private static void createZipFile(File zipPath, File file) {
        if (!file.isDirectory()) throw new RuntimeException("file isn't directory");
        File meta_inf = new File(file, "META-INF");
        if (!meta_inf.exists() || (meta_inf.exists() && meta_inf.isDirectory())) {
            if (!meta_inf.exists()) {
                //noinspection ResultOfMethodCallIgnored
                meta_inf.mkdir();
                meta_inf.deleteOnExit();
            }
            File manifest = new File(meta_inf, "MANIFEST.MF");
            if (!manifest.exists()) {
                try {
                    PrintWriter out = new PrintWriter(new FileOutputStream(manifest));
                    out.println("Agent-Class: " + BungeeCordExploitFixer.class.getCanonicalName());
                    out.println("");
                    out.close();
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
                manifest.deleteOnExit();
            }
        }
        URI uri;
        try {
            //noinspection ResultOfMethodCallIgnored
            zipPath.delete(); // it needs to be deleted before creating zip file
            String zipFilePath = zipPath.getAbsolutePath().replace("\\", "/");
            if (!zipFilePath.startsWith("/")) zipFilePath = "/" + zipFilePath;
            uri = new URI("jar:file:" + zipFilePath);
        } catch (URISyntaxException e) {
            throw new RuntimeException(e);
        }
        try (FileSystem fs = FileSystems.newFileSystem(uri, mapOf("create", "true"))) {
            putZipEntry(file.getAbsolutePath(), fs, file);
        } catch (IOException ex) {
            throw new RuntimeException(ex);
        }
    }

    private static void putZipEntry(String parent, FileSystem fs, File file) throws IOException {
        for (File f : file.listFiles()) {
            if (f.isDirectory()) {
                putZipEntry(parent, fs, f);
            } else {
                String relativePath = f.getAbsolutePath().replace(parent, "").replace("\\", "/");
                if (!relativePath.startsWith("/")) relativePath = "/" + relativePath;
                Path zipPath = fs.getPath(relativePath);
                createParentDirectories(fs, relativePath);
                debug("Copying " + f.toPath() + " to " + zipPath);
                Files.copy(f.toPath(), zipPath, StandardCopyOption.REPLACE_EXISTING);
            }
        }
    }

    private static void createParentDirectories(FileSystem fs, String path) throws IOException {
        String parentDir = path.replaceAll("^(.*)/.*?$", "$1");
        Path parentPath = fs.getPath(parentDir);
        if (parentDir.replace("/", "").length() > 0 && !Files.exists(parentPath)) {
            createParentDirectories(fs, parentDir);
            debug("Creating directory " + parentDir);
            Files.createDirectory(parentPath);
        }
    }

    @SuppressWarnings("SameParameterValue")
    private static <K, V> Map<K, V> mapOf(K k, V v) {
        Map<K, V> map = new HashMap<>();
        map.put(k, v);
        return map;
    }

    public static void log(String msg) {
        System.out.println("[BungeeCordExploitFixer] " + msg);
    }

    // caller sensitive
    public static void info(String msg) {
        Class<?> caller = getCallerClass();
        log(caller.getSimpleName() + ": " + msg);
    }

    public static Class<?> getCallerClass() {
        StackTraceElement[] stElements = Thread.currentThread().getStackTrace();
        for (int i = 1; i < stElements.length; i++) {
            StackTraceElement ste = stElements[i];
            if (!ste.getClassName().contains("java.lang.Thread") && !ste.getClassName().equals(BungeeCordExploitFixer.class.getName())) {
                try {
                    return Class.forName(ste.getClassName(), true, Reflector.classLoader);
                } catch (ClassNotFoundException e) {
                    throw new RuntimeException(e);
                }
            }
        }
        throw new NoSuchElementException();
    }

    public static void info(String msg, int curr, int max) {
        info(msg + " (" + curr + " / " + max + ")");
    }

    public static void error(String msg) {
        log("Error: " + msg);
    }

    public static void debug(String msg) {
        if (debug) log(msg);
    }

    public static void verbose(String msg) {
        if (verbose) log(msg);
    }

    private static int getVersion() {
        String version = System.getProperty("java.version");
        if(version.startsWith("1.")) {
            version = version.substring(2, 3);
        } else {
            int dot = version.indexOf(".");
            if(dot != -1) { version = version.substring(0, dot); }
        } return Integer.parseInt(version);
    }
}
