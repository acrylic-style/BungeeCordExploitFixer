package xyz.acrylicstyle.bcExploitFixer.transformers;

import javassist.ClassPool;
import javassist.CtClass;
import javassist.CtField;
import javassist.CtMethod;
import javassist.NotFoundException;
import xyz.acrylicstyle.bcExploitFixer.BungeeCordExploitFixer;
import xyz.acrylicstyle.bcExploitFixer.util.Util;

import java.lang.instrument.ClassFileTransformer;
import java.lang.reflect.Modifier;
import java.security.ProtectionDomain;

import static xyz.acrylicstyle.bcExploitFixer.BungeeCordExploitFixer.info;

// https://github.com/PaperMC/Waterfall/pull/609
public class BlockOversizedPacketTransformer implements ClassFileTransformer {
    public int transformed = 0;
    public final int max = 4;
    public static final int HANDSHAKE_EXPECTED_MAX_LENGTH = 5 + ((255 * 4 + 3) + 5) + 2 + 1;
    public static final int LOGIN_REQUEST_EXPECTED_MAX_LENGTH = 1 + (16 * 4);
    public static final boolean DEBUG = Boolean.getBoolean("waterfall.packet-decode-logging") || BungeeCordExploitFixer.debug;

    @Override
    public byte[] transform(ClassLoader loader, String className, Class<?> classBeingRedefined, ProtectionDomain protectionDomain, byte[] classfileBuffer) {
        if (!className.equals("net/md_5/bungee/protocol/packet/Handshake")
                && !className.equals("net/md_5/bungee/protocol/Varint21FrameDecoder")
                && !className.equals("net/md_5/bungee/netty/PipelineUtils")
                && !className.equals("net/md_5/bungee/BungeeCord")) return null;
        try {
            ClassPool cp = ClassPool.getDefault();
            CtClass cc = cp.get(className.replace("/", "."));
            if (className.equals("net/md_5/bungee/BungeeCord")) {
                {
                    cc.getDeclaredConstructor(new CtClass[0]).insertAfter("new net.md_5.bungee.protocol.Varint21FrameDecoder();"); // trigger transformer
                }
            }
            if (className.equals("net/md_5/bungee/protocol/packet/Handshake")) {
                {
                    CtMethod method = new CtMethod(CtClass.intType, "expectedMaxLength", new CtClass[] { cp.get("io.netty.buffer.ByteBuf"), cp.get("net.md_5.bungee.protocol.ProtocolConstants$Direction"), CtClass.intType }, cc);
                    method.setBody("return " + HANDSHAKE_EXPECTED_MAX_LENGTH + ";");
                    cc.addMethod(method);
                }
                {
                    CtMethod method = new CtMethod(CtClass.intType, "expectedMinLength", new CtClass[] { cp.get("io.netty.buffer.ByteBuf"), cp.get("net.md_5.bungee.protocol.ProtocolConstants$Direction"), CtClass.intType }, cc);
                    method.setBody("return " + (1 + 1 + 2 + 1) + ";");
                    cc.addMethod(method);
                }
            }
            if (className.equals("net/md_5/bungee/protocol/Varint21FrameDecoder")) {
                {
                    cc.addField(CtField.make("private boolean fromClient = false;", cc));
                    cc.addField(new CtField(CtClass.intType, "packetCount", cc), CtField.Initializer.constant(0));
                    cc.addField(new CtField(cp.get("io.netty.handler.codec.CorruptedFrameException"), "packetLengthOversized", cc), CtField.Initializer.byExpr("new io.netty.handler.codec.CorruptedFrameException(\"Packet #\" + packetCount + \" could not be framed because was too large.\");"));
                    Util.runIfNewConstructor(new CtClass[]{ CtClass.booleanType }, cc, ctor -> {
                        ctor.setBody("this.fromClient = $1;");
                        ctor.setModifiers(Modifier.PUBLIC);
                        cc.addConstructor(ctor);
                    });
                    Util.runConstructor(new CtClass[0], cc, ctor -> ctor.setBody("this(false);"), ctor -> {
                        ctor.setBody("this(false);");
                        ctor.setModifiers(Modifier.PUBLIC);
                        cc.addConstructor(ctor);
                    });
                    CtMethod handleOverflowMethod = new CtMethod(cp.get("java.lang.Exception"), "handleOverflow", new CtClass[]{ CtClass.intType, CtClass.intType, CtClass.intType }, cc);
                    handleOverflowMethod.setBody("        if (" + DEBUG + ") {\n" +
                            "            throw new io.netty.handler.codec.CorruptedFrameException( \"Packet #\" + $1 + \" could not be framed because was too large\" +\n" +
                            "                    \" (expected \" + $2 + \" bytes, got \" + $3 + \" bytes)\");\n" +
                            "        } else {\n" +
                            "            return packetLengthOversized;\n" +
                            "        }");
                    cc.addMethod(handleOverflowMethod);
                    CtMethod method = cc.getDeclaredMethod("decode", cp.get(new String[]{"io.netty.channel.ChannelHandlerContext", "io.netty.buffer.ByteBuf", "java.util.List"}));
                    // copy from waterfall src
                    method.setBody("{\n" +
                        "        if ( !$1.channel().isActive() )\n" +
                        "        {\n" +
                        "            $2.skipBytes( $2.readableBytes() );\n" +
                        "            return;\n" +
                        "        }\n" +
                        "        $2.markReaderIndex();\n" +
                        "        for ( int i = 0; i < 3; i++ )\n" +
                        "        {\n" +
                        "            if ( !$2.isReadable() )\n" +
                        "            {\n" +
                        "                $2.resetReaderIndex();\n" +
                        "                return;\n" +
                        "            }\n" +
                        "            byte read = $2.readByte();\n" +
                        "            if ( read >= 0 )\n" +
                        "            {\n" +
                        "                $2.resetReaderIndex();\n" +
                        "                int length = net.md_5.bungee.protocol.DefinedPacket.readVarInt( $2 );\n" +
                        "                if ( false && length == 0)\n" +
                        "                {\n" +
                        "                    throw new io.netty.handler.codec.CorruptedFrameException( \"Empty Packet!\" );\n" +
                        "                }\n" +
                        "                if (this.fromClient && packetCount < 4) {\n" +
                        "                    int maxLength = 2097151; // max length of 21-bit varint\n" +
                        "                    switch (packetCount) {\n" +
                        "                        case 0:\n" +
                        "                            maxLength = " + (HANDSHAKE_EXPECTED_MAX_LENGTH + 2) + ";\n" +
                        "                            break;\n" +
                        "                        case 1:\n" +
                        "                            maxLength = " + (LOGIN_REQUEST_EXPECTED_MAX_LENGTH + 1) + ";\n" +
                        "                            break;\n" +
                        "                        case 2:\n" +
                        "                            maxLength = 16 + (400 * 4 + 3);\n" +
                        "                            break;\n" +
                        "                        case 3:\n" +
                        "                            maxLength = 16 + (400 * 4 + 3);\n" +
                        "                            break;\n" +
                        "                    }\n" +
                        "                    if (length > maxLength) {\n" +
                        "                        throw handleOverflow(packetCount, maxLength, length);\n" +
                        "                    }\n" +
                        "                    packetCount++;\n" +
                        "                }\n" +
                        "                if ( $2.readableBytes() < length )\n" +
                        "                {\n" +
                        "                    $2.resetReaderIndex();\n" +
                        "                    return;\n" +
                        "                } else {\n" +
                        "                    $3.add($2.readRetainedSlice(length));\n" +
                        "                    return;\n" +
                        "                }\n" +
                        "            }\n" +
                        "        }\n" +
                        "        throw new io.netty.handler.codec.CorruptedFrameException( \"length wider than 21-bit\" );\n}");
                }
            }
            if (className.equals("net/md_5/bungee/netty/PipelineUtils")) {
                {
                    boolean waterfall = false;
                    try {
                        cp.get("io.github.waterfallmc.waterfall.event.ConnectionInitEvent");
                        waterfall = true;
                    } catch (NotFoundException ignore) {}
                    for (CtClass baseClassIn : cc.getNestedClasses()) {
                        if (baseClassIn.getName().equals("net.md_5.bungee.netty.PipelineUtils$Base")) {
                            CtField fromClientField = new CtField(CtClass.booleanType, "fromClient", baseClassIn);
                            fromClientField.setModifiers(Modifier.PRIVATE | Modifier.FINAL);
                            baseClassIn.addField(fromClientField);
                            Util.runIfNewConstructor(new CtClass[]{ CtClass.booleanType }, baseClassIn, ctor -> {
                                ctor.setModifiers(Modifier.PUBLIC);
                                ctor.setBody("this.fromClient = $1;");
                                baseClassIn.addConstructor(ctor);
                            });
                            Util.runIfNewConstructor(new CtClass[0], baseClassIn, ctor -> {
                                ctor.setModifiers(Modifier.PUBLIC);
                                ctor.setBody("this(false);");
                                baseClassIn.addConstructor(ctor);
                            });
                            // modify initChannel(Channel)
                            baseClassIn.getDeclaredMethod("initChannel", new CtClass[]{ cp.get("io.netty.channel.Channel") }).setBody("        {\n" +
                                    "            try\n" +
                                    "            {\n" +
                                    "                io.netty.channel.ChannelConfig.class.getMethod(\"setOption\", new Class[]{ io.netty.channel.ChannelOption.class, Object.class }).invoke($1.config(), new Object[]{ io.netty.channel.ChannelOption.TCP_NODELAY, true });\n" +
                                    "                io.netty.channel.ChannelConfig.class.getMethod(\"setOption\", new Class[]{ io.netty.channel.ChannelOption.class, Object.class }).invoke($1.config(), new Object[]{ io.netty.channel.ChannelOption.IP_TOS, 0x18 });\n" +
                                    "                //$1.config().setOption( io.netty.channel.ChannelOption.IP_TOS, (Object) 0x18 );\n" +
                                    "            } catch ( java.lang.reflect.InvocationTargetException ex )\n" +
                                    "            {\n" +
                                    "                // IP_TOS is not supported (Windows XP / Windows Server 2003)\n" +
                                    "            }\n" +
                                    "            //$1.config().setOption( ChannelOption.TCP_NODELAY, true );\n" +
                                    "            $1.config().setAllocator( io.netty.buffer.PooledByteBufAllocator.DEFAULT );\n" +
                                    "            $1.config().setWriteBufferWaterMark( net.md_5.bungee.netty.PipelineUtils.MARK );\n" +
                                    "\n" +
                                    "            $1.pipeline().addLast( net.md_5.bungee.netty.PipelineUtils.TIMEOUT_HANDLER, new io.netty.handler.timeout.ReadTimeoutHandler( (long) net.md_5.bungee.BungeeCord.getInstance().config.getTimeout(), java.util.concurrent.TimeUnit.MILLISECONDS ) );\n" +
                                    "            $1.pipeline().addLast( net.md_5.bungee.netty.PipelineUtils.FRAME_DECODER, (net.md_5.bungee.protocol.Varint21FrameDecoder) net.md_5.bungee.protocol.Varint21FrameDecoder.class.getConstructor(new Class[]{ boolean.class }).newInstance(new Object[]{ this.fromClient }) );\n" +
                                    "            $1.pipeline().addLast( net.md_5.bungee.netty.PipelineUtils.FRAME_PREPENDER, net.md_5.bungee.netty.PipelineUtils.framePrepender );\n" +
                                    "\n" +
                                    "            $1.pipeline().addLast( net.md_5.bungee.netty.PipelineUtils.BOSS_HANDLER, new net.md_5.bungee.netty.HandlerBoss() );\n" +
                                    "        }");
                            // add field to PipelineUtils
                            CtField limitedBaseField = CtField.make("public static net.md_5.bungee.netty.PipelineUtils.Base LIMITED_BASE;", cc);
                            cc.addField(limitedBaseField);
                            for (CtClass anonClassIn : cc.getNestedClasses()) {
                                if (anonClassIn.getName().equals("net.md_5.bungee.netty.PipelineUtils$1")) {
                                    if (BungeeCordExploitFixer.disableWaterfallCompatibility) waterfall = false;
                                    info("Waterfall: " + waterfall);
                                    StringBuilder sb = new StringBuilder();
                                    sb.append("{\n");
                                    sb.append("            java.net.SocketAddress remoteAddress = ( $1.remoteAddress() == null ) ? $1.parent().localAddress() : $1.remoteAddress();\n");
                                    sb.append("\n");
                                    sb.append("            if ( net.md_5.bungee.BungeeCord.getInstance().getConnectionThrottle() != null && net.md_5.bungee.BungeeCord.getInstance().getConnectionThrottle().throttle( remoteAddress ) )\n");
                                    sb.append("            {\n");
                                    sb.append("                $1.close();\n");
                                    sb.append("                return;\n");
                                    sb.append("            }\n");
                                    sb.append("            net.md_5.bungee.api.config.ListenerInfo listener = $1.attr( net.md_5.bungee.netty.PipelineUtils.LISTENER ).get();\n");
                                    sb.append("\n");
                                    sb.append("            if ( ((net.md_5.bungee.api.event.ClientConnectEvent) net.md_5.bungee.BungeeCord.getInstance().getPluginManager().callEvent( new net.md_5.bungee.api.event.ClientConnectEvent( remoteAddress, listener ) )).isCancelled() )\n");
                                    sb.append("            {\n");
                                    sb.append("                $1.close();\n");
                                    sb.append("                return;\n");
                                    sb.append("            }\n");
                                    sb.append("\n");
                                    sb.append("            if (net.md_5.bungee.netty.PipelineUtils.LIMITED_BASE == null) net.md_5.bungee.netty.PipelineUtils.LIMITED_BASE = new net.md_5.bungee.netty.PipelineUtils.Base(true);\n");
                                    if (waterfall) {
                                        sb.append("            xyz.acrylicstyle.bcExploitFixer.cl.PipelineUtils_1.invoke($1, listener, net.md_5.bungee.netty.PipelineUtils.legacyKicker, net.md_5.bungee.netty.PipelineUtils.LIMITED_BASE);\n");
                                    } else {
                                        sb.append("            net.md_5.bungee.netty.PipelineUtils.LIMITED_BASE.initChannel( $1 );\n");
                                        sb.append("            $1.pipeline().addBefore( net.md_5.bungee.netty.PipelineUtils.FRAME_DECODER, net.md_5.bungee.netty.PipelineUtils.LEGACY_DECODER, new net.md_5.bungee.protocol.LegacyDecoder() );\n");
                                        sb.append("            $1.pipeline().addAfter( net.md_5.bungee.netty.PipelineUtils.FRAME_DECODER, net.md_5.bungee.netty.PipelineUtils.PACKET_DECODER, new net.md_5.bungee.protocol.MinecraftDecoder( net.md_5.bungee.protocol.Protocol.HANDSHAKE, true, net.md_5.bungee.api.ProxyServer.getInstance().getProtocolVersion() ) );\n");
                                        sb.append("            $1.pipeline().addAfter( net.md_5.bungee.netty.PipelineUtils.FRAME_PREPENDER, net.md_5.bungee.netty.PipelineUtils.PACKET_ENCODER, new net.md_5.bungee.protocol.MinecraftEncoder( net.md_5.bungee.protocol.Protocol.HANDSHAKE, true, net.md_5.bungee.api.ProxyServer.getInstance().getProtocolVersion() ) );\n");
                                        sb.append("            $1.pipeline().addBefore( net.md_5.bungee.netty.PipelineUtils.FRAME_PREPENDER, net.md_5.bungee.netty.PipelineUtils.LEGACY_KICKER, net.md_5.bungee.netty.PipelineUtils.legacyKicker );\n");
                                        sb.append("            ((net.md_5.bungee.netty.HandlerBoss) $1.pipeline().get( net.md_5.bungee.netty.HandlerBoss.class )).setHandler( new net.md_5.bungee.connection.InitialHandler( net.md_5.bungee.BungeeCord.getInstance(), listener ) );\n");
                                        sb.append("            if ( listener.isProxyProtocol() )\n");
                                        sb.append("            {\n");
                                        sb.append("                $1.pipeline().addFirst( new io.netty.channel.ChannelHandler[]{ new io.netty.handler.codec.haproxy.HAProxyMessageDecoder() } );\n");
                                        sb.append("            }\n");
                                    }
                                    sb.append("}");
                                    if (BungeeCordExploitFixer.debug) {
                                        info("Injecting code to net.md_5.bungee.netty.PipelineUtils$1#initChannel(io.netty.channel.Channel)");
                                        info(sb.toString());
                                    }
                                    anonClassIn.getDeclaredMethod("initChannel", new CtClass[]{ cp.get("io.netty.channel.Channel") }).setBody(sb.toString());
                                }
                            }
                        }
                    }
                }
            }
            byte[] buf = cc.toBytecode();
            cc.detach();
            info("Transformed " + className, ++transformed, max);
            return buf;
        } catch (Throwable e) {
            info("encountered error during transforming " + className + " - " + e.getClass().getSimpleName() + ": " + e.getMessage());
            e.printStackTrace(System.out);
            throw new RuntimeException(e);
        }
    }
}
